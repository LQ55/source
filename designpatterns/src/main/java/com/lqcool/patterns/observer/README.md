### 观察者模式

**简介：** </br>
观察者模式（Observer Pattern）又叫发布订-阅模式，观察者模式是一种对象行为模式。当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。

**模式结构**
 ![原型模式](https://github.com/lqcool/source/blob/master/designpatterns/src/main/resources/images/%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f%e7%bb%93%e6%9e%84.png)

**观察者模式主要角色**
- Subject：目标，目标中定义了一个观察者集合，存储任意数量的观察者对象，并提供接口来添加新的观察者或则删除观察者，也提供目标变化时候的通知方法。目标类可以是接口也可以是抽象类或者实现类。
- ConcreteSubject：具体的目标类，是目标类的子类，通常包含经常发生改变的数据，状态改变的时候，向它的各个观察者发出通知，同时还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。
- Observer：观察者，它将对观察目标的状态的改变做出相应的响应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。
- ConcreteObserver：具体观察者，它维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。通常在实现的时候，可以调用具体的目标类的attach()方法将自己添加到目标类的观察者集合中或者通过detach()方法将自己从目标的观察者集合中删除。
**有点与缺点：** </br>
- 优点：1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。
- 缺点：1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

**使用场景：**
- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
- 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
- 一个对象必须通知其他对象，而并不知道这些对象是谁。
- 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。


参考文献：</br>
[观察者模式-菜鸟教程](http://www.runoob.com/design-pattern/observer-pattern.html)
